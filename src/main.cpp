#include <fstream>
#include <iostream>
#include <boost/program_options.hpp>
#include <boost/property_tree/json_parser.hpp>
#include <boost/property_tree/xml_parser.hpp>
#include <boost/algorithm/string/replace.hpp>
#include <boost/system/system_error.hpp>

#include "ptree.utils.hpp"
#include "tasks.hpp"

#include "json_spirit/json_spirit.h"

namespace pt = boost::property_tree;
namespace po = boost::program_options;
namespace js = json_spirit;

// Version number & name of the program version.
// Names came from  https://de.wikipedia.org/wiki/Bundesautobahn_20
const std::string ciVersion =
	"(1) Kreuz Lübeck";			// JSON output. (and 1st version with version name)
	// "(2a) Lübeck Genin";
	// "(2b) Lübeck-Süd";
	// "(3) Groß Sarau";
	// "(4) Lüdersdorf";
	// "(5) Schönberg";
	// "(6) Grevesmühlen";
	// ...
	// "(38) Prenzlau-Süd";
	// "(39) Kreuz Uckermark";
	

void printUsage(std::ostream& o)
{
	o << "Usage: ci-run -i <input_path> -o <output_path> [-O <output_file> ] [-r <repo>] [-b <branch>] [-i <commit_id>] [-t <timestamp]  config_file [ config_file... ]\n"
		"\t-i <input_path>    the path where the input files are expected (required)\n"
		"\t-o <output_path>   the path where the output files shall be generated (required)\n"
		"\t-O <output_file>   write generated JSON output into <output_file> (default:stdout)\n"
		"\t-T <template_file> template XML file to generate the output. (default comes from \"output.template.file\" entry in the config file)\n"
		"\t-r <repo>          the name of the repository (optional, only for decorating the output file)\n"
		"\t-b <branch>        the name of the branch (optional, only for decorating the output file)\n"
		"\t-c <commit_id>     guess what!  (optional, only for decorating the output file)\n"
		"\t-t <timestamp>     the timestamp of the commit (optional, only for decorating the output file)\n"
		"\t<config_file>      the config file (at least one is required)\n"
		"\n"
		"(This is ci-run version \"" << ciVersion << "\".)\n"
		"\n";
}


std::string inputPath, outputPath;  // required parameters
std::vector<std::string> configFiles;
std::string outputFileName, outputTemplateFile;
std::string repoName, branchName, commitID, commitTimestamp; // optional parameters
std::string toolchain; // required

int main( int argc, const char* const* argv )
{
	po::options_description desc;
	desc.add_options()
		(",i", po::value<std::string>(&inputPath)->required(),  "the path where the input files are expected (required)")
		(",o", po::value<std::string>(&outputPath)->required(), "the path where the output files shall be generated (required)")
		("output_file,O", po::value<std::string>(&outputFileName)  , "output file")
		("output_template,T", po::value<std::string>(&outputTemplateFile)  , "output template file")
		("repository,r", po::value<std::string>(&repoName)      , "the name of the repository (optional, only for decorating the output file)")
		("branch,b", po::value<std::string>(&branchName)        , "the name of the branch (optional, only for decorating the output file)")
		("commit,c", po::value<std::string>(&commitID)          , "the commit ID (optional, only for decorating the output file)")
		("timestamp,t", po::value<std::string>(&commitTimestamp), "the timestamp of the commit (optional, only for decorating the output file)")
		("filename", po::value< std::vector<std::string> >(&configFiles)->composing(), "the JSON config files (at least one is required)")
		("toolchain", po::value<std::string>(&toolchain)->required(), "the toolchain (gcc, clang, msvc)")
		
		("help,h", "show this text")
		;
	
	po::positional_options_description desc_file;
	desc_file.add("filename", 4711);
	
	
	if(argc==1)
	{
		printUsage(std::cerr); // IMHO more readable than than the output generated by:  std::cerr << desc << '\n';
		return 1;
	}
	
	const std::string argv1 = argv[1];
	if(argv1=="-h" || argv1=="--help")
	{
		printUsage(std::cout);
		return 0; // asking for help is not an error.
	}
	
	po::variables_map vm;
	po::store( po::command_line_parser(argc, argv).options(desc).positional(desc_file).run(), vm);
	po::notify(vm);
	
	if(vm.count("help"))
	{
		std::cout << desc << '\n';
		return 0;
	}

	if(configFiles.empty())
	{
		std::cerr << "\nError: No JSON config file given!\n\n";
		printUsage(std::cerr);
		return 1;
	}

	// read configuration
	pt::ptree config;

	try
	{
		for( const std::string& filename : configFiles )
		{
			std::cout << "\tRead file \"" << filename << "\" ...\n";
			std::ifstream configStream;
			
			configStream.exceptions( std::ifstream::failbit | std::ifstream::badbit );
			configStream.open( filename );
			
			pt::ptree configTree;
			read_json( configStream, configTree );
			
			ptree_merge( config, configTree );
		}
	}
	catch ( const pt::ptree_error& exception )
	{
		std::cerr << "PTree error when reading config file. " << exception.what() << '\n';
		return 1;
	}
	catch ( const std::ifstream::failure& exception )
	{
		std::cerr << "Stream Failure when reading config file. " << exception.what() << '\n';
		return 1;
	}


	bool task_with_error = false;
	
	// run configurations
	js::Array outputTasks;
	try
	{
		for ( auto& taskConfig : config.get_child("tasks") )
		{
			// get task settings
			std::string taskType = taskConfig.second.get<std::string>( "type" );

			boost::optional<std::string> taskVariant = taskConfig.second.get_optional<std::string>( "variant" );

			if(!taskVariant)
				taskVariant = std::string("defaults");

			boost::optional<pt::ptree&> settings_specific = taskConfig.second.get_child_optional( "settings" );
			boost::optional<pt::ptree&> settings_variant = config.get_child_optional( std::string("defaults.") + taskType + std::string(".") + *taskVariant );

			pt::ptree settings;

			if(settings_variant)
				ptree_merge(settings, *settings_variant);

			if(settings_specific)
				ptree_merge(settings, *settings_specific);

			// expand variables
			ptree_traverse
			(
				settings,
				[] (pt::ptree &parent, const pt::ptree::path_type &childPath, pt::ptree &child)
				{
					boost::replace_all(child.data(), "${source.repository}", repoName);
					boost::replace_all(child.data(), "${source.branch}"    , branchName);
					boost::replace_all(child.data(), "${source.commit.id}" , commitID);
					boost::replace_all(child.data(), "${source.commit.timestamp}", commitTimestamp);
					boost::replace_all(child.data(), "${source.path}", inputPath);
					boost::replace_all(child.data(), "${output.path}", outputPath);
				}
			);

			// run task
			auto task = taskTypes.find(taskType);

			if(task != taskTypes.end())
			{
				TaskResult result;

				try
				{
					result = task->second(settings);
				}
				catch(const std::exception& e)
				{
					result.status = TaskResult::STATUS_ERROR;
					result.warnings = 0;
					result.errors = 1;
					result.message = "exception occured";
					result.output.push_back( js::Pair("exception", e.what()));
				}
				
				if(result.status == TaskResult::STATUS_ERROR)
				{
					task_with_error = true;
				}
				
				js::Object outputTask;
				
				outputTask.push_back( js::Pair("type", taskType ));
				outputTask.push_back( js::Pair("name", taskConfig.first ));
				outputTask.push_back( js::Pair("message", result.message ));
				outputTask.push_back( js::Pair("warnings", uint64_t(result.warnings)));
				outputTask.push_back( js::Pair("errors",   uint64_t(result.errors)));
				outputTask.push_back( js::Pair("status", toString(result.status)));
				outputTask.push_back( js::Pair("output", result.output ));
				
				outputTasks.push_back(outputTask);
			}
			else
				throw std::runtime_error(std::string("invalid task type: ") + taskType);
		}
	}
	catch ( const pt::ptree_error& exception )
	{
		std::cerr << "PTree Exception during run: " << exception.what() << '\n';
		return 1;
	}
	catch ( const boost::system::system_error& exception )
	{
		std::cerr << "System Error during run: " << exception.what() << '\n';
		return 1;
	}
	catch ( const std::runtime_error& exception )
	{
		std::cerr << "Runtime Error during run: " << exception.what() << '\n';
		return 1;
	}

	// dump output
	js::Object output;

	try
	{
		output.push_back( js::Pair( "ci-version", ciVersion) );
		output.push_back( js::Pair("project-title", config.get<std::string>("name")));
		output.push_back( js::Pair("project-tasks", outputTasks));

		const js::Output_options options = js::Output_options( js::raw_utf8 | js::pretty_print | js::single_line_arrays );
		std::ostringstream outputStream;
		js::write(output, outputStream, options);
		const std::string outputStr = outputStream.str();

		if(outputFileName.empty())
		{
			std::cout << outputStr << '\n';
		}else{
			std::ofstream of(outputFileName.c_str());
			of << outputStr << '\n';
		}
	}
	catch ( const pt::ptree_error& exception )
	{
		std::cerr << "PTree Error on output. " << exception.what() << '\n';
		return 1;
	}

	return  task_with_error ? 2 : 0;
}
