#include <fstream>
#include <iostream>
#include <boost/program_options.hpp>
#include <boost/property_tree/json_parser.hpp>
#include <boost/property_tree/xml_parser.hpp>
#include <boost/algorithm/string/replace.hpp>
#include <boost/system/system_error.hpp>

#include "ptree.utils.hpp"
#include "tasks.hpp"

namespace pt = boost::property_tree;
namespace po = boost::program_options;


void printUsage(std::ostream& o)
{
	o << "Usage: ci-run -i <input_path> -o <output_path> [-O <output_file> ] [-r <repo>] [-b <branch>] [-i <commit_id>] [-t <timestamp]  config_file [ config_file... ]\n"
		"\t-i <input_path>    the path where the input files are expected (required)\n"
		"\t-o <output_path>   the path where the output files shall be generated (required)\n"
		"\t-O <output_file>   write generated XHTML output into <output_file> (default:stdout)\n"
		"\t-T <template_file> template XML file to generate the output. (default comes from \"output.template.file\" entry in the config file)\n"
		"\t-r <repo>          the name of the repository (optional, only for decorating the output file)\n"
		"\t-b <branch>        the name of the branch (optional, only for decorating the output file)\n"
		"\t-c <commit_id>     guess what!  (optional, only for decorating the output file)\n"
		"\t-t <timestamp>     the timestamp of the commit (optional, only for decorating the output file)\n"
		"\t<config_file>      the config file (at least one is required)\n"
		"\n";
}


std::string inputPath, outputPath;  // required parameters
std::vector<std::string> configFiles;
std::string outputFileName, outputTemplateFile;
std::string repoName, branchName, commitID, commitTimestamp; // optional parameters

int main( int argc, const char* const* argv )
{
	po::options_description desc;
	desc.add_options()
		(",i", po::value<std::string>(&inputPath)->required(),  "the path where the input files are expected (required)")
		(",o", po::value<std::string>(&outputPath)->required(), "the path where the output files shall be generated (required)")
		("output_file,O", po::value<std::string>(&outputFileName)  , "output file")
		("output_template,T", po::value<std::string>(&outputTemplateFile)  , "output template file")
		("repository,r", po::value<std::string>(&repoName)      , "the name of the repository (optional, only for decorating the output file)")
		("branch,b", po::value<std::string>(&branchName)        , "the name of the branch (optional, only for decorating the output file)")
		("commit,c", po::value<std::string>(&commitID)          , "the commit ID (optional, only for decorating the output file)")
		("timestamp,t", po::value<std::string>(&commitTimestamp), "the timestamp of the commit (optional, only for decorating the output file)")
		("filename", po::value< std::vector<std::string> >(&configFiles)->composing(), "the JSON config files (at least one is required)")
		
		("help,h", "show this text")
		;
	
	po::positional_options_description desc_file;
	desc_file.add("filename", 4711);
	
	
	if(argc==1)
	{
		printUsage(std::cerr); // IMHO more readable than than the output generated by:  std::cerr << desc << '\n';
		return 1;
	}
	
	const std::string argv1 = argv[1];
	if(argv1=="-h" || argv1=="--help")
	{
		printUsage(std::cout);
		return 0; // asking for help is not an error.
	}
	
	po::variables_map vm;
	po::store( po::command_line_parser(argc, argv).options(desc).positional(desc_file).run(), vm);
	po::notify(vm);
	
	if(vm.count("help"))
	{
		std::cout << desc << '\n';
		return 0;
	}

	if(configFiles.empty())
	{
		std::cerr << "\nError: No JSON config file given!\n\n";
		printUsage(std::cerr);
		return 1;
	}

	// read configuration
	pt::ptree config;

	try
	{
		for( const std::string& filename : configFiles )
		{
			std::cout << "\tRead file \"" << filename << "\" ...\n";
			std::ifstream configStream;
	
			configStream.exceptions( std::ifstream::failbit | std::ifstream::badbit );
			configStream.open( filename );
	
			pt::ptree configTree;
			read_json( configStream, configTree );
	
			ptree_merge( config, configTree );
		}
	}
	catch ( const pt::ptree_error& exception )
	{
		std::cerr << "PTree error when reading config file. " << exception.what() << '\n';
		return 1;
	}
	catch ( const std::ifstream::failure& exception )
	{
		std::cerr << "Stream Failure when reading config file. " << exception.what() << '\n';
		return 1;
	}


	pt::ptree output;

	bool task_with_error = false;
	
	// run configurations
	pt::ptree outputTasks;

	try
	{
		outputTasks.add_child("tasks", pt::ptree());
		
		for ( auto& taskConfig : config.get_child("tasks") )
		{
			// get task settings
			std::string taskType = taskConfig.second.get<std::string>( "type" );

			boost::optional<std::string> taskVariant = taskConfig.second.get_optional<std::string>( "variant" );

			if(!taskVariant)
				taskVariant = std::string("defaults");

			boost::optional<pt::ptree&> settings_specific = taskConfig.second.get_child_optional( "settings" );
			boost::optional<pt::ptree&> settings_variant = config.get_child_optional( std::string("defaults.") + taskType + std::string(".") + *taskVariant );

			pt::ptree settings;

			if(settings_variant)
				ptree_merge(settings, *settings_variant);

			if(settings_specific)
				ptree_merge(settings, *settings_specific);

			// expand variables
			ptree_traverse
			(
				settings,
				[] (pt::ptree &parent, const pt::ptree::path_type &childPath, pt::ptree &child)
				{
					boost::replace_all(child.data(), "${source.repository}", repoName);
					boost::replace_all(child.data(), "${source.branch}"    , branchName);
					boost::replace_all(child.data(), "${source.commit.id}" , commitID);
					boost::replace_all(child.data(), "${source.commit.timestamp}", commitTimestamp);
					boost::replace_all(child.data(), "${source.path}", inputPath);
					boost::replace_all(child.data(), "${output.path}", outputPath);
				}
			);

			// run task
			auto task = taskTypes.find(taskType);

			if(task != taskTypes.end())
			{
				TaskResult result;

				try
				{
					result = task->second(settings);
				}
				catch(const std::exception& e)
				{
					result.status = TaskResult::STATUS_ERROR;
					result.warnings = 0;
					result.errors = 1;
					result.message = "exception occured";
					result.output.put("pre", e.what());
				}

				if(result.status == TaskResult::STATUS_ERROR)
				{
					task_with_error = true;
				}

				std::ostringstream warningsStr; warningsStr << result.warnings;
				std::ostringstream errorsStr; errorsStr << result.errors;

				pt::ptree outputTask;

				outputTask.add("type", taskType);
				outputTask.add("name", taskConfig.first);
				outputTask.add("message", result.message);
				outputTask.add("warnings", warningsStr.str());
				outputTask.add("errors", errorsStr.str());
				outputTask.add("status", result.status == TaskResult::STATUS_OK ? "Ok" : (result.status == TaskResult::STATUS_WARNING ? "Warning" : "Error"));
				outputTask.add_child("output", result.output );
				
				outputTasks.get_child("tasks").add_child("task", outputTask);
			}
			else
				throw std::runtime_error(std::string("invalid task type: ") + taskType);
		}
	}
	catch ( const pt::ptree_error& exception )
	{
		std::cerr << "PTree Exception during run: " << exception.what() << '\n';
		return 1;
	}
	catch ( const boost::system::system_error& exception )
	{
		std::cerr << "System Error during run: " << exception.what() << '\n';
		return 1;
	}
	catch ( const std::runtime_error& exception )
	{
		std::cerr << "Runtime Error during run: " << exception.what() << '\n';
		return 1;
	}

	// dump output

	try
	{
		output.put(config.get<std::string>("output.template.paths.title"), config.get<std::string>("name"));
		output.put_child(config.get<std::string>("output.template.paths.content"), outputTasks);

		std::ostringstream outputStream;
//		write_xml(outputStream, output , pt::xml_writer_settings<char>('\t', 1));
		write_json(outputStream, output /*, pt::xml_writer_settings<char>('\t', 1)*/);

		std::string outputStr = outputStream.str();

		if(outputFileName.empty())
		{
			std::cout << outputStr << '\n';
		}else{
			std::ofstream of(outputFileName.c_str());
			of << outputStr << '\n';
		}
	}
	catch ( const pt::ptree_error& exception )
	{
		std::cerr << "PTree Error on output. " << exception.what() << '\n';
		return 1;
	}

	return  task_with_error ? 2 : 0;
}
